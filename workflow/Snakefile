# Python standard library
from os.path import join
from os import listdir
import os, sys, re, datetime

# 3rd party imports from pypi
from snakemake.workflow import workflow as wf_api
from snakemake.utils import R

# Local imports
from scripts.common import (
    allocated,
    provided, 
    references,
    str_bool
)

# Timestamp in YYYYMMDD format
today = str(datetime.datetime.today()).split()[0].replace('-', '')

# Global workflow variables
configfile: "config.json"
samples  = config['samples']
workpath = config['project']['workpath']
tmpdir = config['options']['tmp_dir']
genome   = config['options']['genome']         # Reference genome of a set of samples
assay   = config['options']['assay']

# Analysis options
# Run differential binding pipeline
run_dba = True 
if config['options']['contrasts'] == 'None':
    run_dba = False

# Read in resource information,
# containing information about 
# threads, mem, walltimes, etc.
# TODO: Add handler for when the
# mode is set to local.
with open(join('config', 'cluster.json')) as fh:
    cluster = json.load(fh)

# Functions
def outputfiles2(extensions, groupslist, inputnorm):
    """
    Produces correct output filenames based on group information.
    Names will be:
    Inputnorm.Q5DD.RPGC.metagene_heatmap.pdf
    {groupName}.Q5DD.RPGC.metagene_heatmap.pdf
    {groupName}.sorted.RPGC.metagene_heatmap.pdf
    Note: Inputnorm will only be included when there are input samples.
    """
    dtoolgroups, dtoolext = [], []
    
    if len(inputnorm) == 2:
            dtoolgroups.extend(["InputNorm"])
            dtoolext.extend([extensions[1]])
    
    for group in groupslist:
            dtoolgroups.extend([group] * 2)
            dtoolext.extend([extensions[1], extensions[0]])
    
    if len(inputnorm) == 2:
            dtoolgroups.extend(["InputNorm.prot"])
            dtoolext.extend([extensions[1]])
    
    for group in groupslist:
            dtoolgroups.extend([group + ".prot"] * 2)
            dtoolext.extend([extensions[1], extensions[0]])
    
    return dtoolgroups, dtoolext

def zip_contrasts(contrast, PeakTools):
    """making output file names for differential binding analyses"""
    zipGroup1, zipGroup2, zipTool, contrasts = [], [], [], []
    for g1, g2 in contrast:
        for PeakTool in PeakTools:
            zipGroup1.append(g1)
            zipGroup2.append(g2)
            zipTool.append(PeakTool)
            contrasts.append( g1 + "_vs_" + g2 + "-" + PeakTool )
    return(zipGroup1, zipGroup2, zipTool, contrasts)

# Creating naming conventions for bam files 
# and tagAlign files if SE, extension objects 
# defined here are especially relevant for the
# deeptools rules and all four are used in at
# least one rule
se=""
pe=""
if config['project']['nends'] == 2 :
    pe="yes"
elif config['project']['nends'] == 1 :
    se="yes"

extensions = [ "sorted.RPGC", "Q5DD.RPGC" ]
extensions2 = list(map(lambda x:re.sub(".RPGC","",x),extensions))

if pe == "yes":
    extensions3 = { extensions2[i] + "." : "bam" for i in range(len(extensions2)) }
    extensions4 = [ extensions2[i] + ".bam" for i in range(len(extensions2)) ]
else:
    types = [ "bam", "tagAlign.gz" ]
    extensions3 = { extensions2[i] + "." : types[i] for i in range(len(extensions2)) }
    extensions4 = [ extensions2[i] + "." + types[i] for i in range(len(extensions2)) ]


# Getting sample relationships from config
# using ChIP/input nomenclature. NOTE: ATAC
# won't have input samples

###########
chip2input = config['project']['peaks']['inputs'] #{"WT_S1": "Input_S1","WT_S2": "Input_S2","WT_S3": "Input_S3","WT_S4": "Input_S4"}
groupdata = config['project']['groups'] # {"G1": ["WT_S1","WT_S2"],"G2": ["WT_S3","WT_S4"]}

groupdatawinput = {}
groupswreps = []
for group, chipsamples in groupdata.items() :
    tmp = [ ]
    if len(chipsamples) > 1:
        groupswreps.append(group)
    for chip in chipsamples :
        if chip in samples:
            tmp.append(chip)
            input = chip2input[chip]
            if input != 'NA' and input != '':
                tmp.append(input)
    if len(tmp) != 0:
        groupdatawinput[group]=set(tmp)

groups = list(groupdatawinput.keys())

reps="no"
if len(groupswreps) > 0:
    reps="yes"
##############

uniq_inputs = list(sorted(set([v for v in chip2input.values() if v])))

sampleswinput = []
for input in chip2input:
	if chip2input[input] != 'NA' and chip2input[input] != '':
		sampleswinput.append(input)


if len(sampleswinput) == 0:
    inputnorm = [""]
else:
    inputnorm = ["",".inputnorm"]


deepgroups, deepexts = outputfiles2(extensions, groups,inputnorm)



# Directory names
trim_dir='trim'
kraken_dir='kraken'
bam_dir='bam'
bw_dir='bigwig'
deeptools_dir='deeptools'
extra_fingerprint_dir='deeptools/sorted_fingerprint'
qc_dir="QC"
ppqt_dir="ppqt"

macsN_dir = "macsNarrow"
uropa_dir = "UROPA_annotations"
diffbind_dir = "DiffBind"
if assay == "atac": 
    PeakTools = ["macsNarrow", "Genrich"] 
else: 
    PeakTools = ["macsNarrow"]
chips = config['project']['peaks']['chips']
contrast = config['project']['contrast']
UropaCats = ["protTSS", "prot", "protSEC", "genes"]
extensions = ["sorted.RPGC", "Q5DD.RPGC"]

# Setup to run with ChIP samples, 
# which could include IgG samples
cfTool_dir="cfChIPtool"
cfTool_subdir2="cfChIPtool/BED/H3K4me3"

zipGroup1, zipGroup2, zipToolC, contrasts = zip_contrasts(contrast, PeakTools)
# Final targets of the pipeline 

if assay == "cfchip" and reps == "yes":
    rule all:
        input: 
            join(workpath,"multiqc_report.html"),
            expand(join(workpath,qc_dir,"{name}.{ext}.insert_size_metrics.txt"),name=samples,ext=extensions2),
            expand(join(workpath,bam_dir,"{name}.{ext}"),name=samples,ext=extensions4[1]),
            expand(join(workpath,qc_dir,"{name}.preseq.dat"), name=samples),
            expand(join(workpath,macsN_dir,"{name}","{name}_peaks.narrowPeak"),name=chips),
            expand(join(workpath,cfTool_dir,"Output","H3K4me3","Signatures","{name}.Q5DD.csv"),name=chips),
            join(workpath,"QC","H3K4me3_cfChIP_signature.txt"),
            expand(join(workpath,bw_dir,"{name}.{ext}.RPGC.bw"),name=samples, ext=["sorted", "Q5DD"]),
            expand(join(workpath,bw_dir,"{name}.Q5DD.RPGC.inputnorm.bw"), name=sampleswinput),
            expand(join(workpath,diffbind_dir,"{group1}_vs_{group2}-{PeakTool}","{group1}_vs_{group2}-{PeakTool}_Diffbind.html"), zip,group1=zipGroup1,group2=zipGroup2,PeakTool=zipToolC),
            expand(join(workpath,uropa_dir,'{PeakTool}','{name}_{PeakTool}_uropa_{type}_allhits.txt'), PeakTool=PeakTools,name=chips,type=["protTSS"]),
            expand(join(workpath,uropa_dir,diffbind_dir,'{name}_{PeakTool}_uropa_{type}_allhits.txt'), PeakTool=['DiffbindEdgeR','DiffbindDeseq2'],name=contrasts,type=["protTSS"]),
elif assay == "cfchip" and reps == "no":
    rule all:
        input: 
            join(workpath,"multiqc_report.html"),
            expand(join(workpath,qc_dir,"{name}.{ext}.insert_size_metrics.txt"),name=samples,ext=extensions2),
            expand(join(workpath,bam_dir,"{name}.{ext}"),name=samples,ext=extensions4[1]),
            expand(join(workpath,qc_dir,"{name}.preseq.dat"), name=samples),
            expand(join(workpath,macsN_dir,"{name}","{name}_peaks.narrowPeak"),name=chips),
            expand(join(workpath,cfTool_dir,"Output","H3K4me3","Signatures","{name}.Q5DD.csv"),name=H3K4me3samples),
            join(workpath,"QC","H3K4me3_cfChIP_signature.txt"),
            expand(join(workpath,bw_dir,"{name}.{ext}.RPGC.bw"),name=samples, ext=["sorted", "Q5DD"]),
            expand(join(workpath,bw_dir,"{name}.Q5DD.RPGC.inputnorm.bw"), name=sampleswinput),
            expand(join(workpath,uropa_dir,'{PeakTool}','{name}_{PeakTool}_uropa_{type}_allhits.txt'),PeakTool=PeakTools,name=chips,type=["protTSS"]),
elif assay in ["atac", "chip"] and reps == "yes":
    rule all:
        input: 
            join(workpath,"multiqc_report.html"),
            expand(join(workpath,qc_dir,"{name}.{ext}.insert_size_metrics.txt"),name=samples,ext=extensions2),
            expand(join(workpath,bam_dir,"{name}.{ext}"),name=samples,ext=extensions4[1]),
            expand(join(workpath,qc_dir,"{name}.preseq.dat"), name=samples),
            expand(join(workpath,macsN_dir,"{name}","{name}_peaks.narrowPeak"),name=chips),
            expand(join(workpath,bw_dir,"{name}.{ext}.RPGC.bw"),name=samples, ext=["sorted", "Q5DD"]),
            expand(join(workpath,bw_dir,"{name}.Q5DD.RPGC.inputnorm.bw"), name=sampleswinput),
            expand(join(workpath,diffbind_dir,"{group1}_vs_{group2}-{PeakTool}","{group1}_vs_{group2}-{PeakTool}_Diffbind.html"), zip,group1=zipGroup1,group2=zipGroup2,PeakTool=zipToolC),
            expand(join(workpath,uropa_dir,'{PeakTool}','{name}_{PeakTool}_uropa_{type}_allhits.txt'),
                PeakTool=PeakTools,name=chips,type=["protTSS", "prot", "protSEC", "genes"]),
            expand(join(workpath,uropa_dir,diffbind_dir,'{name}_{PeakTool}_uropa_{type}_allhits.txt'), 
                PeakTool=['DiffbindEdgeR','DiffbindDeseq2'],name=contrasts,type=["protTSS", "prot", "protSEC", "genes"]),
elif assay in ["atac", "chip"] and reps == "no":
    rule all:
        input: 
            join(workpath,"multiqc_report.html"),
            expand(join(workpath,qc_dir,"{name}.{ext}.insert_size_metrics.txt"),name=samples,ext=extensions2),
            expand(join(workpath,bam_dir,"{name}.{ext}"),name=samples,ext=extensions4[1]),
            expand(join(workpath,qc_dir,"{name}.preseq.dat"), name=samples),
            expand(join(workpath,macsN_dir,"{name}","{name}_peaks.narrowPeak"),name=chips),
            expand(join(workpath,bw_dir,"{name}.{ext}.RPGC.bw"),name=samples, ext=["sorted", "Q5DD"]),
            expand(join(workpath,bw_dir,"{name}.Q5DD.RPGC.inputnorm.bw"), name=sampleswinput),
            expand(join(workpath,uropa_dir,'{PeakTool}','{name}_{PeakTool}_uropa_{type}_allhits.txt'),
                PeakTool=PeakTools,name=chips,type=["protTSS", "prot", "protSEC", "genes"]),
#############################

# QC/alignment rules: trim_pe,
# BWA_PE, picard_dedup, bam2bw,
# inputnorm
include: "rules/trim_align_dedup.smk"

# QC rules common to all: preseq, NRF,
# rawfastqc, fastqc, fastq_screen, 
# kraken_pe, multiqc, insert_size
include: "rules/qc.smk"

# MACS2_narrow
# if assay=="atac" then run rules sortByRead and genrich
include: "rules/peakcall.smk"

#FRiP, FRiP_plot, jaccard rules
include: "rules/peakcall_qc.smk"

#UROPA, DiffBind, and manorm rules
include: "rules/dba.smk"

# cfChIP-specific QC rules:
# cfChIPtool, cfChIPcompile,
# promoterTable1:, and promoterTable2
if assay == "cfchip":
    include: "rules/cfChIP.smk"
